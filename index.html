<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mini Monopoly 5√ó5 - Multiplayer Edition</title>
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

<style>
* {
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  text-align: center;
  margin: 0;
  padding: 20px;
  min-height: 100vh;
}

h2 {
  color: white;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  margin-bottom: 10px;
}

#status {
  color: white;
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 15px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

/* Menu Screen */
#menu-screen {
  max-width: 600px;
  margin: 50px auto;
  background: white;
  padding: 40px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

#menu-screen h3 {
  color: #2c3e50;
  margin-bottom: 30px;
  font-size: 24px;
}

.menu-button {
  display: block;
  width: 100%;
  padding: 20px;
  margin: 15px 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.menu-button:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

.menu-button:active {
  transform: translateY(0);
}

.menu-button.ai {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

.menu-button.online {
  background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

.menu-button.local {
  background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
}

.menu-button .subtitle {
  font-size: 14px;
  opacity: 0.9;
  margin-top: 5px;
  font-weight: normal;
}

/* Player Count Selection */
#player-count-screen {
  display: none;
  max-width: 500px;
  margin: 50px auto;
  background: white;
  padding: 40px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

#player-count-screen h3 {
  color: #2c3e50;
  margin-bottom: 30px;
}

.player-count-btn {
  display: inline-block;
  width: 80px;
  padding: 20px;
  margin: 10px;
  background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.player-count-btn:hover {
  transform: translateY(-3px);
}

/* Online Lobby */
#online-lobby {
  display: none;
  max-width: 500px;
  margin: 50px auto;
  background: white;
  padding: 30px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

#online-lobby h3 {
  color: #2c3e50;
  margin-bottom: 20px;
}

.lobby-section {
  margin: 20px 0;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.lobby-input {
  width: 100%;
  padding: 12px;
  margin: 10px 0;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.room-code-display {
  font-size: 32px;
  font-weight: bold;
  color: #667eea;
  letter-spacing: 4px;
  padding: 15px;
  background: white;
  border-radius: 8px;
  margin: 15px 0;
}

.connection-status {
  padding: 10px;
  border-radius: 6px;
  margin: 10px 0;
  font-weight: bold;
}

.status-waiting {
  background: #fff3cd;
  color: #856404;
}

.status-connected {
  background: #d4edda;
  color: #155724;
}

.status-error {
  background: #f8d7da;
  color: #721c24;
}

#game-screen {
  display: none;
}

#wrap {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

/* Mobile-friendly: stack panels above board on small screens */
@media (max-width: 768px) {
  #board {
    width: 90vw !important;
    height: 90vw !important;
    max-width: 540px;
    max-height: 540px;
  }
  
  .controls {
    width: 90% !important;
    max-width: 540px;
  }
  
  .controls button {
    font-size: 12px !important;
    padding: 8px 12px !important;
  }
}

#board {
  width: 540px;
  height: 540px;
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 6px;
  background: #2c3e50;
  padding: 10px;
  border-radius: 12px;
  box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}

.tile {
  border: 2px solid #34495e;
  background: white;
  font-size: 10px;
  position: relative;
  padding: 6px 4px;
  border-radius: 6px;
  transition: transform 0.2s, box-shadow 0.2s;
  overflow: hidden;
}

.tile:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.tile-header {
  font-weight: bold;
  margin-bottom: 3px;
  padding: 2px;
  border-radius: 3px;
  font-size: 11px;
}

.row-0 { background: #8d6e63; color: white; }
.row-1 { background: #81d4fa; color: #333; }
.row-2 { background: #f48fb1; color: white; }
.row-3 { background: #ffb74d; color: #333; }
.row-4 { background: #ef5350; color: white; }

.luck-tile {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%) !important;
}

.jail-tile {
  background: linear-gradient(135deg, #607d8b 0%, #90a4ae 100%) !important;
}

.connection-line {
  position: absolute;
  background: currentColor;
  opacity: 0.4;
  pointer-events: none;
  z-index: 10;
}

.connection-right {
  right: -3px;
  top: 50%;
  transform: translateY(-50%);
  width: 6px;
  height: 40%;
}

.connection-down {
  bottom: -3px;
  left: 50%;
  transform: translateX(-50%);
  height: 6px;
  width: 40%;
}

.tile.sellable {
  cursor: pointer;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.8) !important;
  border: 3px solid #4CAF50 !important;
}

.tile.sellable:hover {
  transform: translateY(-4px) !important;
  box-shadow: 0 6px 12px rgba(76, 175, 80, 0.9) !important;
}

.tile.buildable {
  cursor: pointer;
  box-shadow: 0 0 10px rgba(255, 152, 0, 0.8) !important;
  border: 3px solid #FF9800 !important;
}

.tile.buildable:hover {
  transform: translateY(-4px) !important;
  box-shadow: 0 6px 12px rgba(255, 152, 0, 0.9) !important;
}

.tile-info {
  line-height: 1.3;
}

.token-container {
  position: absolute;
  bottom: 4px;
  left: 4px;
  right: 4px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.token {
  animation: tokenPop 0.3s ease-out;
}

@keyframes tokenPop {
  0% { transform: scale(0); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

.circle {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid black;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.triangle {
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-bottom: 16px solid;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.square {
  width: 16px;
  height: 16px;
  border: 2px solid black;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.diamond {
  width: 16px;
  height: 16px;
  transform: rotate(45deg);
  border: 2px solid black;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.controls {
  margin: 15px auto;
  text-align: center;
  max-width: 600px;
}

button {
  padding: 10px 16px;
  margin: 4px;
  background: #3498db;
  border: none;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

button:hover:not(:disabled) {
  background: #2980b9;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

button:active:not(:disabled) {
  transform: translateY(0);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.active {
  background: #27ae60;
}

#rollBtn {
  font-size: 16px;
  padding: 12px 24px;
  transition: all 0.2s;
}

#rollBtn:hover:not(:disabled) {
  filter: brightness(0.9);
}

#endBtn {
  background: #16a085;
  font-size: 16px;
  padding: 12px 24px;
}

#endBtn:hover:not(:disabled) {
  background: #138871;
}

#buyBtn {
  background: #27ae60;
}

#buyBtn:hover:not(:disabled) {
  background: #229954;
}

#houseBtn {
  background: #f39c12;
}

#houseBtn:hover:not(:disabled) {
  background: #d68910;
}

#villaBtn {
  background: #9b59b6;
}

#villaBtn:hover:not(:disabled) {
  background: #8e44ad;
}

#sellBtn {
  background: #e67e22;
}

#sellBtn:hover:not(:disabled) {
  background: #d35400;
}

#bailBtn {
  background: #34495e;
}

#bailBtn:hover:not(:disabled) {
  background: #2c3e50;
}

#log {
  background: rgba(255,255,255,0.95);
  border: 2px solid #333;
  height: 180px;
  overflow-y: auto;
  text-align: left;
  padding: 12px;
  margin: 15px auto;
  max-width: 600px;
  border-radius: 8px;
  font-size: 13px;
  line-height: 1.6;
  box-shadow: 0 4px 6px rgba(0,0,0,0.2);
}

.log-action {
  color: #2c3e50;
  font-weight: 600;
}

.log-income {
  color: #27ae60;
  font-weight: 600;
}

.log-expense {
  color: #e74c3c;
  font-weight: 600;
}

#ai-thinking {
  display: none;
  color: white;
  font-size: 16px;
  margin: 10px 0;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  max-width: 600px;
  margin: 10px auto;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.thinking {
  animation: pulse 1s infinite;
}

/* Build Mode Indicator */
#build-mode-indicator {
  display: none;
  background: rgba(255, 152, 0, 0.95);
  color: white;
  padding: 12px;
  border-radius: 8px;
  margin: 10px auto;
  max-width: 600px;
  font-weight: bold;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
</style>

</head>
<body>

<!-- Menu Screen -->
<div id="menu-screen">
  <h3>üé≤ Mini Monopoly 5√ó5</h3>
  <button class="menu-button local" onclick="showPlayerSetup()">
    üè† Local Play
    <div class="subtitle">2-4 players (Human or AI)</div>
  </button>
  <button class="menu-button online" onclick="showOnlineLobby()">
    üåê Online Play
    <div class="subtitle">Play with friends remotely</div>
  </button>
</div>

<!-- Player Setup Screen -->
<div id="player-setup-screen" style="display:none; max-width:700px; margin:50px auto; background:white; padding:40px; border-radius:16px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
  <h3>Setup Game</h3>
  
  <p><strong>Number of Players:</strong></p>
  <div style="margin:20px 0;">
    <button class="player-count-btn" onclick="setupPlayers(2)">2</button>
    <button class="player-count-btn" onclick="setupPlayers(3)">3</button>
    <button class="player-count-btn" onclick="setupPlayers(4)">4</button>
  </div>
  
  <div id="player-slots" style="margin:30px 0;"></div>
  
  <button class="menu-button" id="start-btn" style="display:none;" onclick="startLocalWithAI()">‚ñ∂Ô∏è Start Game</button>
  <button class="menu-button" onclick="backToMenu()">‚¨ÖÔ∏è Back</button>
</div>

<!-- Online Lobby -->
<div id="online-lobby">
  <h3>üåê Online Lobby</h3>
  
  <div class="lobby-section">
    <h4>Host a Game</h4>
    <button class="menu-button" onclick="hostGame()">Create Room</button>
    <div id="room-code-section" style="display: none;">
      <p>Share this code with your friend:</p>
      <div class="room-code-display" id="room-code"></div>
      <div class="connection-status status-waiting" id="host-status">
        Waiting for opponent to join...
      </div>
    </div>
  </div>
  
  <div class="lobby-section">
    <h4>Join a Game</h4>
    <input 
      type="text" 
      class="lobby-input" 
      id="join-code-input" 
      placeholder="Enter room code"
      maxlength="6"
    >
    <button class="menu-button" onclick="joinGame()">Join Room</button>
    <div class="connection-status" id="join-status" style="display: none;"></div>
  </div>
  
  <button class="menu-button" onclick="backToMenu()">‚¨ÖÔ∏è Back to Menu</button>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <h2>üé≤ Mini Monopoly 5√ó5</h2>
  <div id="status"></div>
  <div id="ai-thinking" class="thinking">ü§ñ AI is thinking...</div>
  <div id="build-mode-indicator"></div>

  <div id="wrap">
    <div id="board"></div>
  </div>

<div class="controls">
  <button id="rollBtn" onclick="roll()">üé≤ Roll [SPACE]</button>
  <button id="bailBtn" class="warning-btn" onclick="payBail()">üîì Bail [B]</button>
  <button id="buyBtn" class="action-btn" onclick="buy()">üí∞ Buy [B]</button>
  <button id="buildBtn" class="action-btn" onclick="toggleBuildMode()">üèóÔ∏è Build [H]</button>
  <button id="sellBtn" class="danger-btn" onclick="toggleSellMode()">üí∏ Sell [S]</button>
  <button id="tradeBtn" class="action-btn" onclick="openTradeMenu()">ü§ù Trade [T]</button>
  <button id="endBtn" onclick="end()">‚úÖ End [ENTER]</button>
</div>

  <div id="log"></div>

  <div class="controls">
    <button id="soundBtn" onclick="toggleSound()" class="active">üîä Sound ON</button>
    <button onclick="exportLogs()">üìã Export Logs</button>
    <button onclick="forfeit()">üè≥Ô∏è Forfeit</button>
  </div>
</div>


<!-- Trade Modal -->
<div id="trade-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:2000; overflow-y:auto;">
  <div style="background:white; max-width:700px; margin:30px auto; padding:30px; border-radius:12px;">
    <h3 style="color:#2c3e50; margin-top:0;">ü§ù Trade Center</h3>
    
    <div style="margin:20px 0;">
      <label style="font-weight:bold;">Trade with:</label>
      <select id="trade-partner" onchange="updateTradePartner()" style="width:200px; padding:8px; margin-left:10px; border:1px solid #ddd; border-radius:4px; font-size:14px;">
        <!-- Populated dynamically -->
      </select>
    </div>
    
    <div style="display:grid; grid-template-columns:1fr auto 1fr; gap:15px; margin:25px 0;">
      <!-- Your Offer -->
      <div style="border:3px solid #2196F3; padding:20px; border-radius:10px; background:#f8f9fa;">
        <h4 style="margin-top:0; color:#2196F3;">Your Offer</h4>
        <div id="your-offer">
          <div style="margin-bottom:15px;">
            <label style="font-weight:bold;">üí∞ Cash: $</label>
            <input type="number" id="your-cash" value="0" min="0" style="width:100px; padding:6px; border:1px solid #ddd; border-radius:4px;" oninput="updateTradeSummary()">
          </div>
          <label style="font-weight:bold; display:block; margin-bottom:10px;">üè† Properties:</label>
          <div id="your-properties" style="max-height:250px; overflow-y:auto; border:1px solid #ddd; padding:10px; border-radius:4px; background:white;">
            <!-- Checkboxes -->
          </div>
        </div>
      </div>
      
      <div style="display:flex; align-items:center; font-size:32px; color:#666;">
        ‚Üî
      </div>
      
      <!-- Their Offer -->
      <div style="border:3px solid #F44336; padding:20px; border-radius:10px; background:#f8f9fa;">
        <h4 style="margin-top:0; color:#F44336;">Their Offer</h4>
        <div id="their-offer">
          <div style="margin-bottom:15px;">
            <label style="font-weight:bold;">üí∞ Cash: $</label>
            <input type="number" id="their-cash" value="0" min="0" style="width:100px; padding:6px; border:1px solid #ddd; border-radius:4px;" oninput="updateTradeSummary()">
          </div>
          <label style="font-weight:bold; display:block; margin-bottom:10px;">üè† Properties:</label>
          <div id="their-properties" style="max-height:250px; overflow-y:auto; border:1px solid #ddd; padding:10px; border-radius:4px; background:white;">
            <!-- Checkboxes -->
          </div>
        </div>
      </div>
    </div>
    
    <div style="margin:20px 0; padding:20px; background:#e8f5e9; border-radius:8px; border-left:4px solid #4CAF50;">
      <strong style="color:#2c3e50;">üìã Trade Summary:</strong>
      <div id="trade-summary" style="margin-top:10px; line-height:1.8;"></div>
    </div>
    
    <div style="display:flex; gap:15px; justify-content:center;">
      <button class="menu-button" style="background:#4CAF50; flex:1; max-width:200px;" onclick="proposeTrade()">üì§ Propose Trade</button>
      <button class="menu-button" style="background:#666; flex:1; max-width:200px;" onclick="closeTradeMenu()">‚ùå Cancel</button>
    </div>
  </div>
</div>

<!-- Trade Proposal Modal -->
<div id="trade-proposal-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2001;">
  <div style="background:white; max-width:500px; margin:80px auto; padding:35px; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
    <h3 style="color:#2c3e50; margin-top:0;">ü§ù Trade Proposal</h3>
    <div id="proposal-details" style="margin:25px 0; text-align:left; line-height:1.8;"></div>
    <div style="display:flex; gap:15px; justify-content:center; margin-top:30px;">
      <button class="menu-button" style="background:#4CAF50; padding:15px 30px; font-size:16px;" onclick="acceptTrade()">‚úÖ Accept</button>
      <button class="menu-button" style="background:#f44336; padding:15px 30px; font-size:16px;" onclick="rejectTrade()">‚ùå Reject</button>
    </div>
  </div>
</div>

<script>
// === GAME CONSTANTS ===
const START = 1500;
const HOUSE = 200; // Base reference (actual cost = property price)
const VILLA = 500; // Base reference (actual cost = house cost)
const REF = 0.8; // 80% refund
const LUCK = [6, 18];
const JAIL = 12;
const BAIL = 300;
const PASS_MONEY = 100;

let tiles = [];
let current = 0;
let rolled = false;
let players = [];
let gameMode = null;
let soundEnabled = true;
let sellingMode = false;
let buildMode = null; // 'house' or 'villa'
let numPlayers = 2;

// Online multiplayer variables
let peer = null;
let conn = null;
let isHost = false;
let isMyTurn = true;
let myPlayerIndex = 0;
let roomCode = '';

// Player colors and shapes for 2-4 players
const PLAYER_CONFIGS = [
  { color: "#2196F3", shape: "circle", name: "Player 1" },
  { color: "#F44336", shape: "triangle", name: "Player 2" },
  { color: "#9C27B0", shape: "square", name: "Player 3" },
  { color: "#FF9800", shape: "diamond", name: "Player 4" }
];

// Rent values
const rv = [10, 25, 75, 225, 500];

// === UI FUNCTIONS ===
function showPlayerCountScreen() {
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('player-count-screen').style.display = 'block';
}

function backToMenu() {
  document.getElementById('menu-screen').style.display = 'block';
  document.getElementById('player-count-screen').style.display = 'none';
  document.getElementById('online-lobby').style.display = 'none';
  document.getElementById('game-screen').style.display = 'none';
  
  if (peer) {
    peer.destroy();
    peer = null;
  }
  if (conn) {
    conn.close();
    conn = null;
  }
  
  gameMode = null;
  resetGame();
}

function showOnlineLobby() {
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('online-lobby').style.display = 'block';
}

// === ONLINE MULTIPLAYER ===
function hostGame() {
  roomCode = generateRoomCode();
  peer = new Peer(roomCode);
  
  peer.on('open', function(id) {
    document.getElementById('room-code').textContent = roomCode;
    document.getElementById('room-code-section').style.display = 'block';
    isHost = true;
    myPlayerIndex = 0;
  });
  
  peer.on('connection', function(connection) {
    conn = connection;
    setupConnection();
    document.getElementById('host-status').textContent = 'Opponent connected! Starting game...';
    document.getElementById('host-status').className = 'connection-status status-connected';
    
    setTimeout(() => {
      startGame('online');
    }, 1000);
  });
  
  peer.on('error', function(err) {
    console.error('Peer error:', err);
    alert('Connection error. Please try again.');
  });
}

function joinGame() {
  let code = document.getElementById('join-code-input').value.toUpperCase().trim();
  
  if (code.length !== 6) {
    alert('Please enter a valid 6-character room code');
    return;
  }
  
  peer = new Peer();
  
  peer.on('open', function() {
    conn = peer.connect(code);
    setupConnection();
    isHost = false;
    myPlayerIndex = 1;
    
    document.getElementById('join-status').style.display = 'block';
    document.getElementById('join-status').textContent = 'Connecting...';
    document.getElementById('join-status').className = 'connection-status status-waiting';
  });
  
  peer.on('error', function(err) {
    console.error('Peer error:', err);
    document.getElementById('join-status').style.display = 'block';
    document.getElementById('join-status').textContent = 'Failed to connect. Check the room code.';
    document.getElementById('join-status').className = 'connection-status status-error';
  });
}

function setupConnection() {
  conn.on('open', function() {
    if (!isHost) {
      document.getElementById('join-status').textContent = 'Connected! Starting game...';
      document.getElementById('join-status').className = 'connection-status status-connected';
      
      setTimeout(() => {
        startGame('online');
      }, 1000);
    }
  });
  
  conn.on('data', function(data) {
    handleRemoteAction(data);
  });
  
  conn.on('close', function() {
    alert('Connection lost. Returning to menu.');
    backToMenu();
  });
}

function sendAction(action, extra = {}) {
  if (conn && conn.open) {
    conn.send({ action, ...extra });
  }
}

function sendGameState() {
  if (conn && conn.open && isHost) {
    conn.send({
      action: 'sync',
      tiles: tiles,
      players: players,
      current: current,
      rolled: rolled
    });
  }
}

function handleRemoteAction(data) {
  if (data.action === 'sync') {
    tiles = data.tiles;
    players = data.players;
    current = data.current;
    rolled = data.rolled;
    
    isMyTurn = (isHost && current === 0) || (!isHost && current === 1);
    
    draw();
    status();
    updateButtons();
    return;
  }
  
  switch(data.action) {
    case 'roll':
      handleRemoteRoll(data.d1, data.d2);
      break;
    case 'buy':
      handleRemoteBuy();
      break;
    case 'house':
      handleRemoteHouse(data.tileIndex);
      break;
    case 'villa':
      handleRemoteVilla(data.tileIndex);
      break;
    case 'sell':
      handleRemoteSell(data.tileIndex);
      break;
    case 'bail':
      handleRemoteBail();
      break;
    case 'end':
      handleRemoteEnd();
      break;
  }
}

function handleRemoteRoll(d1, d2) {
  let otherPlayer = isHost ? 1 : 0;
  
  if (players[otherPlayer].jailTurns > 0) {
    if (d1 === d2) {
      players[otherPlayer].jailTurns = 0;
      log(`üéâ ${players[otherPlayer].name} rolled DOUBLES and escaped jail!`, "log-income");
    } else {
      log(`üé≤ ${players[otherPlayer].name} rolled ${d1} + ${d2} = ${d1+d2} (still in jail)`, "log-action");
      rolled = true;
      draw();
      status();
      updateButtons();
      return;
    }
  }
  
  players[otherPlayer].pos = (players[otherPlayer].pos + d1 + d2) % 25;
  
  if (players[otherPlayer].pos < d1 + d2 && !LUCK.includes(players[otherPlayer].pos)) {
    players[otherPlayer].money += PASS_MONEY;
    log(`üí∞ ${players[otherPlayer].name} passed START! +$${PASS_MONEY}`, "log-income");
  }
  
  log(`üé≤ ${players[otherPlayer].name} rolled ${d1} + ${d2} = ${d1+d2}`, "log-action");
  rolled = true;
  
  handleLanding(otherPlayer);
  
  draw();
  status();
  updateButtons();
}

function handleRemoteBuy() {
  let otherPlayer = isHost ? 1 : 0;
  let i = players[otherPlayer].pos;
  tiles[i].o = otherPlayer;
  players[otherPlayer].money -= price(i);
  log(`üè† ${players[otherPlayer].name} bought Tile ${i} for $${price(i)}`, "log-action");
  
  draw();
  updateButtons();
}

function handleRemoteHouse(tileIndex) {
  let otherPlayer = isHost ? 1 : 0;
  let cost = houseCost(tileIndex);
  players[otherPlayer].money -= cost;
  tiles[tileIndex].h++;
  log(`üî® ${players[otherPlayer].name} built a house on Tile ${tileIndex} for $${cost}`, "log-action");
  
  draw();
  updateButtons();
}

function handleRemoteVilla(tileIndex) {
  let otherPlayer = isHost ? 1 : 0;
  let cost = villaCost(tileIndex);
  players[otherPlayer].money -= cost;
  tiles[tileIndex].h = 0;
  tiles[tileIndex].v = true;
  log(`üè∞ ${players[otherPlayer].name} built a VILLA on Tile ${tileIndex} for $${cost}!`, "log-action");
  
  draw();
  updateButtons();
}

function handleRemoteSell(tileIndex) {
  let otherPlayer = isHost ? 1 : 0;
  let t = tiles[tileIndex];
  
  if (t.v) {
    let refund = villaCost(tileIndex) * REF;
    players[otherPlayer].money += refund;
    t.v = false;
    t.h = 3;
    log(`üí∞ ${players[otherPlayer].name} sold villa on Tile ${tileIndex} for $${refund}`, "log-income");
  } else if (t.h) {
    let refund = houseCost(tileIndex) * REF;
    players[otherPlayer].money += refund;
    t.h--;
    log(`üí∞ ${players[otherPlayer].name} sold house on Tile ${tileIndex} for $${refund}`, "log-income");
  } else {
    players[otherPlayer].money += price(tileIndex) * REF;
    t.o = null;
    log(`üí∞ ${players[otherPlayer].name} sold property Tile ${tileIndex} for $${price(tileIndex) * REF}`, "log-income");
  }
  
  draw();
  updateButtons();
}

function handleRemoteBail() {
  let otherPlayer = isHost ? 1 : 0;
  players[otherPlayer].money -= BAIL;
  players[otherPlayer].jailTurns = 0;
  log(`üîì ${players[otherPlayer].name} paid $${BAIL} bail and is FREE!`, "log-income");
  
  draw();
  status();
  updateButtons();
}

function handleRemoteEnd() {
  rolled = false;
  switchTurn();
}

function generateRoomCode() {
  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// === GAME INITIALIZATION ===
function startGame(mode, playerCount = 2) {
  gameMode = mode;
  numPlayers = mode === 'online' || mode === 'ai' ? 2 : playerCount;
  
  // Hide all screens
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('player-count-screen').style.display = 'none';
  document.getElementById('online-lobby').style.display = 'none';
  document.getElementById('game-screen').style.display = 'block';
  
  resetGame();
  initBoard();
  
  if (gameMode === 'online') {
    isMyTurn = (isHost && current === 0) || (!isHost && current === 1);
  }
  
  draw();
  status();
  updateButtons();
  log(`üéÆ Game started! ${numPlayers} players`, "log-action");
}

function initBoard() {
  tiles = [];
  for (let i = 0; i < 25; i++) {
    tiles.push({
      o: null,
      h: 0,
      v: false
    });
  }
}

// === UTILITY FUNCTIONS ===
function log(msg, className = "") {
  let l = document.getElementById("log");
  let entry = document.createElement("div");
  entry.className = className;
  entry.textContent = msg;
  l.appendChild(entry);
  l.scrollTop = l.scrollHeight;
}

function beep(freq, duration = 0.1) {
  if (!soundEnabled) return;
  let ctx = new (window.AudioContext || window.webkitAudioContext)();
  let osc = ctx.createOscillator();
  let gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.frequency.value = freq;
  gain.gain.value = 0.1;
  osc.start();
  setTimeout(() => osc.stop(), duration * 1000);
}

function status() {
  let p = players[current];
  let jailInfo = p.jailTurns > 0 ? ` üöî (${p.jailTurns} turns in jail)` : '';
  let turnInfo = gameMode === 'online' ? (isMyTurn ? ' - YOUR TURN' : ' - Waiting...') : '';
  document.getElementById("status").textContent = 
    `${p.name}'s Turn${jailInfo}${turnInfo} | Money: $${p.money} | Total: $${wealth(current)}`;
}

function wealth(pIdx) {
  let w = players[pIdx].money;
  for (let i = 0; i < 25; i++) {
    if (tiles[i].o === pIdx) {
      w += price(i);
      w += tiles[i].h * HOUSE;
      if (tiles[i].v) w += VILLA;
    }
  }
  return w;
}

function price(i) {
  if (LUCK.includes(i)) return 0;
  let row = Math.floor(i / 5);
  return [100, 150, 200, 300, 400][row];
}

function houseCost(i) {
  return Math.floor(price(i) / 2); // House cost = half of property price
}

function villaCost(i) {
  return Math.floor(price(i) / 2); // Villa upgrade cost = half of property price
}

// === CLUSTER DETECTION ===
function getCluster(tileIndex) {
  let visited = new Set();
  let cluster = [];
  let owner = tiles[tileIndex].o;
  
  if (owner === null || LUCK.includes(tileIndex)) return [];
  
  function dfs(idx) {
    if (visited.has(idx)) return;
    if (LUCK.includes(idx)) return;
    if (tiles[idx].o !== owner) return;
    
    visited.add(idx);
    cluster.push(idx);
    
    // Get neighbors
    let neighbors = getNeighbors(idx);
    neighbors.forEach(n => dfs(n));
  }
  
  dfs(tileIndex);
  return cluster;
}

function getNeighbors(idx) {
  let row = Math.floor(idx / 5);
  let col = idx % 5;
  let neighbors = [];
  
  // Right
  if (col < 4 && !LUCK.includes(idx) && !LUCK.includes(idx + 1)) {
    neighbors.push(idx + 1);
  }
  
  // Left
  if (col > 0 && !LUCK.includes(idx) && !LUCK.includes(idx - 1)) {
    neighbors.push(idx - 1);
  }
  
  // Down
  if (row < 4 && !LUCK.includes(idx) && !LUCK.includes(idx + 5)) {
    neighbors.push(idx + 5);
  }
  
  // Up
  if (row > 0 && !LUCK.includes(idx) && !LUCK.includes(idx - 5)) {
    neighbors.push(idx - 5);
  }
  
  return neighbors;
}

// Check if tile can be built on (even building rule)
function canBuildHouse(tileIndex) {
  let cluster = getCluster(tileIndex);
  if (cluster.length < 3) return false;
  
  let tile = tiles[tileIndex];
  if (tile.v) return false;
  if (tile.h >= 3) return false;
  
  // Even building rule: can't have more than 1 house difference
  let minHouses = Math.min(...cluster.map(i => tiles[i].v ? 4 : tiles[i].h));
  let maxHouses = Math.max(...cluster.map(i => tiles[i].v ? 4 : tiles[i].h));
  
  // If building here would create >1 difference, block it
  let newHouses = tile.h + 1;
  if (newHouses > minHouses + 1) return false;
  
  return true;
}

function canBuildVilla(tileIndex) {
  let cluster = getCluster(tileIndex);
  if (cluster.length < 3) return false;
  
  let tile = tiles[tileIndex];
  if (tile.v) return false;
  if (tile.h !== 3) return false;
  
  // Even building rule for villa (treat villa as 4 houses)
  let minHouses = Math.min(...cluster.map(i => tiles[i].v ? 4 : tiles[i].h));
  
  // Building villa (=4 houses) when min is <3 would violate even rule
  if (minHouses < 3) return false;
  
  return true;
}

// Check if cluster has 3+ owned tiles
function adjacent(i) {
  let cluster = getCluster(i);
  return cluster.length >= 3;
}

// === DRAWING ===
function draw() {
  let board = document.getElementById("board");
  board.innerHTML = "";
  
  for (let i = 0; i < 25; i++) {
    let tile = document.createElement("div");
    tile.className = "tile";
    tile.id = `tile${i}`;
    
    let row = Math.floor(i / 5);
    let rowClass = `row-${row}`;
    
    let isLuck = LUCK.includes(i);
    let isJail = i === JAIL;
    
    if (isLuck) {
      tile.classList.add("luck-tile");
    } else if (isJail) {
      tile.classList.add("jail-tile");
    }
    
    let header = document.createElement("div");
    header.className = `tile-header ${rowClass}`;
    
    if (isLuck) {
      header.textContent = "üçÄ LUCK";
    } else if (isJail) {
      header.textContent = "üöî JAIL";
    } else {
      header.textContent = `#${i}`;
    }
    
    tile.appendChild(header);
    
    if (!isLuck && !isJail) {
      let info = document.createElement("div");
      info.className = "tile-info";
      
      let p = price(i);
      let row = Math.floor(i / 5);
      
      // Calculate base rent based on property price
      // Row 0: 1/30 of $100 = ~3.3 ‚Üí use 3
      // Row 4: 1/10 of $400 = 40
      let baseRent;
      if (row === 0) baseRent = Math.floor(100 / 30); // ~3
      else if (row === 1) baseRent = Math.floor(150 / 25); // 6
      else if (row === 2) baseRent = Math.floor(200 / 20); // 10
      else if (row === 3) baseRent = Math.floor(300 / 15); // 20
      else if (row === 4) baseRent = Math.floor(400 / 10); // 40
      
      info.innerHTML = `<div style="font-weight: bold;">$${p}</div>`;
      
      let t = tiles[i];
      
      if (t.o !== null) {
        let ownerColor = players[t.o].color;
        // Change tile background to owner's color with transparency
        tile.style.background = `linear-gradient(135deg, ${ownerColor}33 0%, ${ownerColor}66 100%)`;
        
        info.innerHTML += `<div style="color: ${ownerColor}; font-weight: bold; font-size: 10px;">${players[t.o].name}</div>`;
        
        if (t.v) {
          info.innerHTML += `<div style="font-size: 10px;">üè∞ Villa</div>`;
        } else if (t.h > 0) {
          info.innerHTML += `<div style="font-size: 10px;">üè† ${t.h}H</div>`;
        }
      } else {
        // Show rent info for unowned properties
        // Multipliers: 5x, 15x, 37x, 45x
        info.innerHTML += `<div style="font-size: 8px; line-height: 1.3; margin-top: 2px;">
          R: $${baseRent}<br>
          1H: $${baseRent * 5} | 2H: $${baseRent * 15}<br>
          3H: $${baseRent * 37} | V: $${baseRent * 45}
        </div>`;
      }
      
      tile.appendChild(info);
      
      // Connection lines for adjacent tiles
      let neighbors = getNeighbors(i);
      let col = i % 5;
      
      if (t.o !== null && !isLuck) {
        neighbors.forEach(n => {
          if (tiles[n].o === t.o) {
            let nCol = n % 5;
            if (nCol > col) {
              let line = document.createElement("div");
              line.className = "connection-line connection-right";
              line.style.color = players[t.o].color;
              tile.appendChild(line);
            }
            if (n > i && nCol === col) {
              let line = document.createElement("div");
              line.className = "connection-line connection-down";
              line.style.color = players[t.o].color;
              tile.appendChild(line);
            }
          }
        });
      }
    }
    
    // Token container
    let tokenContainer = document.createElement("div");
    tokenContainer.className = "token-container";
    
    players.forEach((p, pIdx) => {
      if (p.pos === i) {
        let token = document.createElement("div");
        token.className = `token ${p.shape}`;
        token.style.backgroundColor = p.color;
        token.style.borderColor = p.color;
        tokenContainer.appendChild(token);
      }
    });
    
    tile.appendChild(tokenContainer);
    
    // Click handlers for sell and build modes
    if (sellingMode) {
      let t = tiles[i];
      if (t.o === current && !LUCK.includes(i)) {
        tile.classList.add("sellable");
        tile.onclick = () => sellTile(i);
      }
    } else if (buildMode) {
      let t = tiles[i];
      if (t.o === current && !LUCK.includes(i)) {
        if (buildMode === 'house' && canBuildHouse(i)) {
          tile.classList.add("buildable");
          tile.onclick = () => buildOnTile(i, 'house');
        } else if (buildMode === 'villa' && canBuildVilla(i)) {
          tile.classList.add("buildable");
          tile.onclick = () => buildOnTile(i, 'villa');
        }
      }
    }
    
    board.appendChild(tile);
  }
}

function updateButtons() {
  let inJail = players[current].jailTurns > 0;
  let canRoll = !rolled || inJail;
  let canEndTurn = rolled || inJail;
  
  // Update Roll button color to current player's color
  let rollBtn = document.getElementById('rollBtn');
  rollBtn.style.background = players[current].color;
  rollBtn.style.boxShadow = `0 2px 8px ${players[current].color}88`;
  
  // Trade button - BUG FIX B
  let canTrade = rolled && gameMode === 'local' && players.filter(p => !p.isAI).length > 1;
  document.getElementById('tradeBtn').disabled = !canTrade;
  
  // Online mode restrictions
  if (gameMode === 'online' && !isMyTurn) {
    document.getElementById('rollBtn').disabled = true;
    document.getElementById('endBtn').disabled = true;
    document.getElementById('buyBtn').disabled = true;
    document.getElementById('houseBtn').disabled = true;
    document.getElementById('villaBtn').disabled = true;
    document.getElementById('sellBtn').disabled = true;
    document.getElementById('bailBtn').disabled = true;
    return;
  }
  
  document.getElementById('rollBtn').disabled = !canRoll;
  document.getElementById('endBtn').disabled = !canEndTurn;
  
  let i = players[current].pos;
  let t = tiles[i];
  
  // Buy button
  let canBuy = rolled && !LUCK.includes(i) && t.o === null && players[current].money >= price(i);
  document.getElementById('buyBtn').disabled = !canBuy;
  
  // Bail button
  let canBail = inJail && players[current].money >= BAIL;
  document.getElementById('bailBtn').disabled = !canBail;
  document.getElementById('bailBtn').style.display = inJail ? 'inline-block' : 'none';
  
  // House/Villa/Sell buttons - can always use if you have eligible properties
  let hasOwnedProps = tiles.some((tile, idx) => tile.o === current && !LUCK.includes(idx));
  let canBuildHouseAnywhere = tiles.some((tile, idx) => {
    if (tile.o === current && canBuildHouse(idx)) {
      return players[current].money >= houseCost(idx);
    }
    return false;
  });
  let canBuildVillaAnywhere = tiles.some((tile, idx) => {
    if (tile.o === current && canBuildVilla(idx)) {
      return players[current].money >= villaCost(idx);
    }
    return false;
  });
  
  document.getElementById('houseBtn').disabled = !canBuildHouseAnywhere;
  document.getElementById('villaBtn').disabled = !canBuildVillaAnywhere;
  document.getElementById('sellBtn').disabled = !hasOwnedProps;
}

// === BUILD MODE ===
function enterBuildMode(type) {
  if (gameMode === 'online' && !isMyTurn) return;
  
  if (buildMode === type) {
    exitBuildMode();
    return;
  }
  
  if (sellingMode) {
    toggleSellMode();
  }
  
  buildMode = type;
  
  let indicator = document.getElementById('build-mode-indicator');
  indicator.style.display = 'block';
  indicator.textContent = type === 'house' 
    ? 'üè† BUILD HOUSE MODE: Click on any property in a cluster of 3+ to build' 
    : 'üè∞ BUILD VILLA MODE: Click on any property with 3 houses in a cluster of 3+ to build';
  
  draw();
  
  // Update button appearance
  if (type === 'house') {
    document.getElementById('houseBtn').classList.add('active');
    document.getElementById('villaBtn').classList.remove('active');
  } else {
    document.getElementById('villaBtn').classList.add('active');
    document.getElementById('houseBtn').classList.remove('active');
  }
}

function exitBuildMode() {
  buildMode = null;
  document.getElementById('build-mode-indicator').style.display = 'none';
  document.getElementById('houseBtn').classList.remove('active');
  document.getElementById('villaBtn').classList.remove('active');
  draw();
}

function buildOnTile(tileIndex, type) {
  if (gameMode === 'online' && !isMyTurn) return;
  
  let t = tiles[tileIndex];
  
  if (type === 'house') {
    if (!canBuildHouse(tileIndex)) return;
    
    let cost = houseCost(tileIndex);
    if (players[current].money < cost) return;
    
    players[current].money -= cost;
    t.h++;
    log(`üî® ${players[current].name} built a house on Tile ${tileIndex} for $${cost}`, "log-action");
    beep(500);
    
    if (gameMode === 'online' && isMyTurn) {
      sendAction('house', { tileIndex });
    }
  } else if (type === 'villa') {
    if (!canBuildVilla(tileIndex)) return;
    
    let cost = villaCost(tileIndex);
    if (players[current].money < cost) return;
    
    players[current].money -= cost;
    t.h = 0;
    t.v = true;
    log(`üè∞ ${players[current].name} built a VILLA on Tile ${tileIndex} for $${cost}!`, "log-action");
    beep(300, 0.3);
    
    if (gameMode === 'online' && isMyTurn) {
      sendAction('villa', { tileIndex });
    }
  }
  
  draw();
  updateButtons();
  
  // Stay in build mode after building
}

// === SELL MODE ===
function toggleSellMode() {
  if (gameMode === 'online' && !isMyTurn) return;
  
  sellingMode = !sellingMode;
  
  if (buildMode) {
    exitBuildMode();
  }
  
  let btn = document.getElementById("sellBtn");
  if (sellingMode) {
    btn.classList.add("active");
    btn.textContent = "üèöÔ∏è Exit Sell Mode";
  } else {
    btn.classList.remove("active");
    btn.textContent = "üèöÔ∏è Sell Mode (S)";
  }
  
  draw();
  beep(400, 0.1);
}

function sellTile(tileIndex) {
  if (gameMode === 'online' && !isMyTurn) return;
  
  let t = tiles[tileIndex];
  
  if (t.v) {
    let refund = villaCost(tileIndex) * REF;
    players[current].money += refund;
    t.v = false;
    t.h = 3;
    log(`üí∞ ${players[current].name} sold villa on Tile ${tileIndex} for $${refund}`, "log-income");
  } else if (t.h) {
    let refund = houseCost(tileIndex) * REF;
    players[current].money += refund;
    t.h--;
    log(`üí∞ ${players[current].name} sold house on Tile ${tileIndex} for $${refund}`, "log-income");
  } else {
    players[current].money += price(tileIndex) * REF;
    t.o = null;
    log(`üí∞ ${players[current].name} sold property Tile ${tileIndex} for $${price(tileIndex) * REF}`, "log-income");
  }
  
  beep(250);
  
  if (gameMode === 'online' && isMyTurn) {
    sendAction('sell', { tileIndex });
  }
  
  draw();
  updateButtons();
}

// === GAME ACTIONS ===
window.roll = async function() {
  if (gameMode === 'online' && !isMyTurn) return;
  
  let inJail = players[current].jailTurns > 0;
  
  if (!inJail && rolled) return;
  
  let d1 = Math.floor(Math.random() * 6) + 1;
  let d2 = Math.floor(Math.random() * 6) + 1;
  
  if (gameMode === 'online' && isMyTurn) {
    sendAction('roll', { d1, d2 });
  }
  
  if (inJail) {
    if (d1 === d2) {
      players[current].jailTurns = 0;
      log(`üéâ ${players[current].name} rolled DOUBLES (${d1} + ${d2}) and escaped jail!`, "log-income");
      beep(800);
    } else {
      log(`üé≤ ${players[current].name} rolled ${d1} + ${d2} = ${d1+d2} (still in jail)`, "log-action");
      beep(300);
      rolled = true;
      draw();
      status();
      updateButtons();
      return;
    }
  }
  
  let oldPos = players[current].pos;
  players[current].pos = (players[current].pos + d1 + d2) % 25;
  
  // Check if passed START
  if (players[current].pos < oldPos ) {
    players[current].money += PASS_MONEY;
    log(`üí∞ ${players[current].name} passed START! +$${PASS_MONEY}`, "log-income");
    beep(600);
  }
  
  log(`üé≤ ${players[current].name} rolled ${d1} + ${d2} = ${d1+d2}`, "log-action");
  beep(500);
  rolled = true;
  
  handleLanding(current);
  
  draw();
  status();
  updateButtons();
  
  if (gameMode === 'ai' && current === 1) {
    await aiTurn();
  }
}

function handleLanding(playerIndex) {
  let i = players[playerIndex].pos;
  let t = tiles[i];
  
  if (LUCK.includes(i)) {
    let luck = Math.random() < 0.5;
    let amount = Math.floor(Math.random() * 100) + 50;
    
    if (luck) {
      players[playerIndex].money += amount;
      log(`üçÄ ${players[playerIndex].name} got LUCKY! +$${amount}`, "log-income");
      beep(700);
    } else {
      players[playerIndex].money -= amount;
      log(`üí∏ ${players[playerIndex].name} got UNLUCKY! -$${amount}`, "log-expense");
      beep(300);
    }
    
    checkBankruptcy();
    return;
  }
  
  if (i === JAIL) {
    players[playerIndex].jailTurns = 3;
    log(`üöî ${players[playerIndex].name} landed in JAIL for 3 turns!`, "log-action");
    beep(200, 0.3);
    return;
  }
  
  if (t.o === null) {
    log(`üèòÔ∏è Unowned property! Buy or End turn.`, "log-action");
    return;
  }
  
  if (t.o === playerIndex) {
    log(`üè† ${players[playerIndex].name} landed on their own property`, "log-action");
    return;
  }
  
  // Pay rent
  let row = Math.floor(i / 5);
  
  // Calculate base rent
  let baseRent;
  if (row === 0) baseRent = Math.floor(100 / 30); // ~3
  else if (row === 1) baseRent = Math.floor(150 / 25); // 6
  else if (row === 2) baseRent = Math.floor(200 / 20); // 10
  else if (row === 3) baseRent = Math.floor(300 / 15); // 20
  else if (row === 4) baseRent = Math.floor(400 / 10); // 40
  
  let pay;
  
  if (t.v) {
    pay = baseRent * 45; // Villa = 45x base rent
  } else if (t.h === 3) {
    pay = baseRent * 37; // 3 houses = 37x base rent
  } else if (t.h === 2) {
    pay = baseRent * 15; // 2 houses = 15x base rent
  } else if (t.h === 1) {
    pay = baseRent * 5; // 1 house = 5x base rent
  } else {
    pay = baseRent; // Base rent
  }
  
  players[playerIndex].money -= pay;
  players[t.o].money += pay;
  log(`üí∏ ${players[playerIndex].name} paid ${players[t.o].name} $${pay} rent`, "log-expense");
  beep(400, 0.2);
  checkBankruptcy();
}

function checkBankruptcy() {
  for (let i = 0; i < numPlayers; i++) {
    if (players[i].money < 0) {
      // Try to auto-sell cheapest assets
      let debt = Math.abs(players[i].money);
      let ownedProperties = [];
      
      // Collect all owned properties with their values
      for (let tileIdx = 0; tileIdx < 25; tileIdx++) {
        if (tiles[tileIdx].o === i && !LUCK.includes(tileIdx)) {
          let value = price(tileIdx) * REF;
          if (tiles[tileIdx].v) {
            value += villaCost(tileIdx) * 3 * REF; // 3 houses + villa upgrade
          } else if (tiles[tileIdx].h > 0) {
            value += houseCost(tileIdx) * tiles[tileIdx].h * REF;
          }
          ownedProperties.push({ tileIdx, value, tile: tiles[tileIdx] });
        }
      }
      
      // Sort by value (cheapest first)
      ownedProperties.sort((a, b) => a.value - b.value);
      
      // Sell assets starting from cheapest
      for (let prop of ownedProperties) {
        if (players[i].money >= 0) break;
        
        let tileIdx = prop.tileIdx;
        let t = tiles[tileIdx];
        
        // Sell villa first if exists
        if (t.v) {
          let refund = villaCost(tileIdx) * REF;
          players[i].money += refund;
          t.v = false;
          t.h = 3;
          log(`üí∞ Auto-sold villa on Tile ${tileIdx} for $${refund}`, "log-income");
        }
        
        // Sell houses one by one
        while (t.h > 0 && players[i].money < 0) {
          let refund = houseCost(tileIdx) * REF;
          players[i].money += refund;
          t.h--;
          log(`üí∞ Auto-sold house on Tile ${tileIdx} for $${refund}`, "log-income");
        }
        
        // Sell property itself if still in debt
        if (players[i].money < 0) {
          let refund = price(tileIdx) * REF;
          players[i].money += refund;
          t.o = null;
          log(`üí∞ Auto-sold property Tile ${tileIdx} for $${refund}`, "log-income");
        }
      }
      
      // If still bankrupt after selling everything
      if (players[i].money < 0) {
        alert(`${players[i].name} went BANKRUPT! Game Over!`);
        endGame(true);
      } else {
        log(`‚ö†Ô∏è ${players[i].name} auto-sold assets to cover debt!`, "log-action");
        draw();
      }
    }
  }
}

window.buy = function() {
  if (gameMode === 'online' && !isMyTurn) return;
  
  let i = players[current].pos;
  
  // BUG FIX C: Check if property is already owned
  if (tiles[i].o !== null) {
    beep(200, 0.1);
    log(`‚ùå Tile ${i} is already owned!`, "log-expense");
    return;
  }
  
  tiles[i].o = current;
  players[current].money -= price(i);
  log(`üè† ${players[current].name} bought Tile ${i} for $${price(i)}`, "log-action");
  beep(700);
  
  draw();
  updateButtons();
  
  if (gameMode === 'online' && isMyTurn) {
    sendAction('buy');
  }
}

// Legacy house/villa functions (for current tile only) - now redirects to build mode
window.house = function() {
  enterBuildMode('house');
}

window.villa = function() {
  enterBuildMode('villa');
}

window.payBail = function() {
  if (gameMode === 'online' && !isMyTurn) return;
  if (players[current].jailTurns === 0) return;
  if (players[current].money < BAIL) return;
  
  players[current].money -= BAIL;
  players[current].jailTurns = 0;
  log(`üîì ${players[current].name} paid $${BAIL} bail and is FREE!`, "log-income");
  beep(600);
  
  if (gameMode === 'online' && isMyTurn) {
    sendAction('bail');
  }
  
  draw();
  status();
  updateButtons();
}

window.end = function() {
  let inJail = players[current].jailTurns > 0;
  
  if (!rolled && !inJail) return;
  if (gameMode === 'online' && !isMyTurn) return;
  
  if (sellingMode) {
    toggleSellMode();
  }
  
  if (buildMode) {
    exitBuildMode();
  }
  
  // If in jail and tried to roll (but didn't get doubles), decrement jail counter
  if (inJail && rolled) {
    players[current].jailTurns--;
    if (players[current].jailTurns === 0) {
      log(`üéâ ${players[current].name} is FREE from jail!`, "log-income");
    } else {
      log(`üöî ${players[current].name} stays in jail. ${players[current].jailTurns} turns remaining.`, "log-action");
    }
  } else if (!inJail) {
    log(`‚úÖ ${players[current].name} ended turn`, "log-action");
  }
  
  rolled = false;
  
  if (gameMode === 'online' && isMyTurn) {
    sendAction('end');
  }
  
  switchTurn();
}

function switchTurn() {
  current = (current + 1) % numPlayers;
  rolled = false;
  
  // Close any open modals
  if (buildMode) toggleBuildMode();
  if (sellingMode) toggleSellMode();
  
  draw();
  status();
  updateButtons();
  updatePanels();
  
  // Trigger AI turn if it's an AI player
  if (gameMode === 'local' && players[current] && players[current].isAI) {
    setTimeout(aiTurn, 1000);
  }
}

// AI Logic

function toggleSound() {
  soundEnabled = !soundEnabled;
  let btn = document.getElementById("soundBtn");
  btn.textContent = soundEnabled ? "üîä Sound ON" : "üîá Sound OFF";
  btn.classList.toggle("active");
  beep(500, 0.1);
}

function exportLogs() {
  let logElement = document.getElementById("log");
  let timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  
  let gameState = {
    timestamp: new Date().toISOString(),
    gameMode: gameMode,
    numPlayers: numPlayers,
    currentPlayer: current,
    players: players.map((p, idx) => ({
      name: p.name,
      money: p.money,
      position: p.pos,
      jailTurns: p.jailTurns,
      totalWealth: wealth(idx),
      properties: tiles.map((t, i) => t.o === idx ? i : null).filter(x => x !== null)
    })),
    tiles: tiles.map((t, idx) => ({
      index: idx,
      owner: t.o,
      houses: t.h,
      villa: t.v
    })).filter(t => t.owner !== null),
    log: logElement.innerText
  };
  
  let content = "MINI MONOPOLY GAME LOG\n";
  content += "=".repeat(50) + "\n\n";
  content += "Game State at Export:\n";
  content += JSON.stringify(gameState, null, 2);
  content += "\n\n" + "=".repeat(50) + "\n\n";
  content += "Game Log:\n" + gameState.log;
  
  let blob = new Blob([content], { type: 'text/plain' });
  let url = URL.createObjectURL(blob);
  let a = document.createElement('a');
  a.href = url;
  a.download = `monopoly-log-${timestamp}.txt`;
  a.click();
  URL.revokeObjectURL(url);
  
  log("üìã Game logs exported successfully!", "log-action");
  beep(600, 0.1);
}

function forfeit() {
  if (confirm(`Are you sure ${players[current].name} wants to forfeit?`)) {
    // Remove current player from game
    let remainingPlayers = players.filter((p, idx) => idx !== current);
    
    if (remainingPlayers.length === 1) {
      // Only one player left - they win
      alert(`${remainingPlayers[0].name} wins by forfeit! üéâ`);
      backToMenu();
    } else {
      // Multiple players remain
      alert(`${players[current].name} has forfeited! Game continues with ${remainingPlayers.length} players.`);
      
      // Transfer properties to bank (make them unowned)
      for (let i = 0; i < 25; i++) {
        if (tiles[i].o === current) {
          tiles[i].o = null;
          tiles[i].h = 0;
          tiles[i].v = false;
        }
      }
      
      // Adjust other players' owner indices
      for (let i = 0; i < 25; i++) {
        if (tiles[i].o !== null && tiles[i].o > current) {
          tiles[i].o--;
        }
      }
      
      // Remove player and adjust current turn
      players.splice(current, 1);
      numPlayers--;
      
      if (current >= numPlayers) {
        current = 0;
      }
      
      draw();
      status();
      updateButtons();
    }
  }
}

function endGame(forfeit = false) {
  let wealths = players.map((p, idx) => ({ idx, wealth: wealth(idx) }));
  wealths.sort((a, b) => b.wealth - a.wealth);
  let winner = forfeit ? wealths.find(w => w.idx !== current).idx : wealths[0].idx;
  
  let msg = forfeit 
    ? `${players[winner].name} wins by forfeit! üéâ`
    : `üèÜ GAME OVER!\n\n${wealths.map(w => `${players[w.idx].name}: $${w.wealth}`).join('\n')}\n\nWinner: ${players[winner].name}! üéâ`;
  
  alert(msg);
  backToMenu();
}

function resetGame() {
  tiles = [];
  current = 0;
  rolled = false;
  sellingMode = false;
  buildMode = null;
  
  players = [];
  for (let i = 0; i < (numPlayers || 2); i++) {
    players.push({
      pos: 0,
      money: START,
      jailTurns: 0,
      ...PLAYER_CONFIGS[i]
    });
  }
  
  isMyTurn = true;
  myPlayerIndex = 0;
  document.getElementById('log').innerHTML = '';
  document.getElementById('build-mode-indicator').style.display = 'none';
}


// ===== AI & TRADING SYSTEM =====

let playerSetup = [];
let currentTrade = null;

// Player Setup Functions
function showPlayerSetup() {
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('player-setup-screen').style.display = 'block';
}

function setupPlayers(count) {
  playerSetup = [];
  const slotsDiv = document.getElementById('player-slots');
  slotsDiv.innerHTML = '<h4 style="color:#2c3e50; margin-bottom:20px;">Configure Each Player:</h4>';
  
  const icons = ['üîµ', 'üî∫', 'üü©', 'üüß'];
  const colors = ['Blue', 'Red', 'Green', 'Orange'];
  
  for (let i = 0; i < count; i++) {
    playerSetup.push({ type: 'human', name: `Player ${i+1}` });
    
    const slot = document.createElement('div');
    slot.style.cssText = 'display:grid; grid-template-columns:40px 1fr auto; align-items:center; gap:12px; margin:12px 0; padding:15px; background:#f8f9fa; border-radius:8px; border-left:4px solid ' + ['#2196F3','#F44336','#4CAF50','#FF9800'][i];
    slot.innerHTML = `
      <span style="font-size:28px;">${icons[i]}</span>
      <input type="text" id="p${i}-name" value="Player ${i+1}" style="padding:10px; border:1px solid #ddd; border-radius:6px; font-size:14px;">
      <select id="p${i}-type" onchange="updatePlayerType(${i}, this.value)" style="padding:10px; border:1px solid #ddd; border-radius:6px; font-size:14px; min-width:120px;">
        <option value="human">üë§ Human</option>
        <option value="ai">ü§ñ AI</option>
      </select>
    `;
    slotsDiv.appendChild(slot);
  }
  
  document.getElementById('start-btn').style.display = 'inline-block';
}

function updatePlayerType(index, type) {
  playerSetup[index].type = type;
  const nameInput = document.getElementById(`p${index}-name`);
  if (type === 'ai') {
    nameInput.value = `ü§ñ AI ${index + 1}`;
  } else {
    nameInput.value = `Player ${index + 1}`;
  }
}

function startLocalWithAI() {
  // Get player configurations
  playerSetup.forEach((p, i) => {
    p.name = document.getElementById(`p${i}-name`).value;
  });
  
  // Set number of players
  numPlayers = playerSetup.length;
  
  // Use existing startGame but customize
  gameMode = 'local';
  
  // Hide screens
  document.getElementById('player-setup-screen').style.display = 'none';
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('game-screen').style.display = 'block';
  
  // Initialize game
  resetGame();
  initBoard();
  
  // Set player types and names
  players.forEach((player, i) => {
    if (playerSetup[i]) {
      player.name = playerSetup[i].name;
      player.isAI = playerSetup[i].type === 'ai';
    }
  });
  
  draw();
  status();
  updateButtons();
  
  log(`üéÆ Game started with ${numPlayers} players!`, 'log-action');
  
  // If first player is AI, start their turn
  if (players[0] && players[0].isAI) {
    setTimeout(aiTurn, 1000);
  }
}

// Enhanced AI Turn Logic
async function aiTurn() {
  if (!players[current] || !players[current].isAI || gameMode !== 'local') return;
  
  await new Promise(r => setTimeout(r, 500));
  
  // Handle jail
  if (players[current].jailTurns > 0) {
    if (players[current].money >= BAIL * 2) {
      payBail();
      await new Promise(r => setTimeout(r, 800));
    }
  }
  
  // Roll dice
  if (!rolled && players[current].jailTurns === 0) {
    await roll();
    await new Promise(r => setTimeout(r, 1200));
  }
  
  // Buy property if good value
  let pos = players[current].pos;
  if (tiles[pos] && tiles[pos].o === null && !LUCK.includes(pos) && pos !== JAIL_TILE) {
    let propertyPrice = price(pos);
    if (players[current].money >= propertyPrice * 2.5) {
      await new Promise(r => setTimeout(r, 600));
      buy();
      await new Promise(r => setTimeout(r, 600));
    }
  }
  
  // Build houses strategically
  await aiBuilding();
  
  // End turn
  await new Promise(r => setTimeout(r, 800));
  end();
}

async function aiBuilding() {
  // Find buildable tiles
  let buildable = [];
  tiles.forEach((t, idx) => {
    if (t.o === current && canBuildHouse(idx) && !t.v) {
      let cost = houseCost(idx);
      if (players[current].money >= cost * 3) {
        buildable.push({ idx, cost, rent: baseRent(idx) });
      }
    }
  });
  
  if (buildable.length > 0) {
    // Sort by rent value (build on valuable properties first)
    buildable.sort((a, b) => b.rent - a.rent);
    
    // Try to build on best property
    for (let prop of buildable.slice(0, 2)) {
      if (canBuildHouseEvenly(prop.idx)) {
        buildOnTile(prop.idx, 'house');
        await new Promise(r => setTimeout(r, 700));
        break;
      }
    }
  }
}

// Trading System
function openTradeMenu() {
  if (gameMode !== 'local') {
    alert('‚ùå Trading only available in local multiplayer!');
    return;
  }
  
  // Count human players
  const humanPlayers = players.filter((p, idx) => idx !== current && (!p.isAI || p.isAI === false));
  
  if (humanPlayers.length === 0) {
    alert('‚ùå No other human players to trade with!\n\n(AI players don\'t trade)');
    return;
  }
  
  // Populate partner selection
  const partnerSelect = document.getElementById('trade-partner');
  partnerSelect.innerHTML = '';
  
  players.forEach((p, idx) => {
    if (idx !== current && !p.isAI) {
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = p.name;
      partnerSelect.appendChild(option);
    }
  });
  
  updateTradePartner();
  document.getElementById('trade-modal').style.display = 'block';
}

function updateTradePartner() {
  const partnerId = parseInt(document.getElementById('trade-partner').value);
  
  // Populate your properties
  const yourProps = document.getElementById('your-properties');
  yourProps.innerHTML = '';
  
  let hasProps = false;
  tiles.forEach((t, idx) => {
    if (t.o === current) {
      hasProps = true;
      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.margin = '8px 0';
      label.style.padding = '6px';
      label.style.cursor = 'pointer';
      label.innerHTML = `
        <input type="checkbox" class="your-prop-check" value="${idx}" onchange="updateTradeSummary()">
        <strong>Tile ${idx}</strong> (${t.h}üè†${t.v ? '+üè∞' : ''}) - $${price(idx)}
      `;
      yourProps.appendChild(label);
    }
  });
  
  if (!hasProps) {
    yourProps.innerHTML = '<em style="color:#999;">No properties to trade</em>';
  }
  
  // Populate their properties
  const theirProps = document.getElementById('their-properties');
  theirProps.innerHTML = '';
  
  let hasTheirProps = false;
  tiles.forEach((t, idx) => {
    if (t.o === partnerId) {
      hasTheirProps = true;
      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.margin = '8px 0';
      label.style.padding = '6px';
      label.style.cursor = 'pointer';
      label.innerHTML = `
        <input type="checkbox" class="their-prop-check" value="${idx}" onchange="updateTradeSummary()">
        <strong>Tile ${idx}</strong> (${t.h}üè†${t.v ? '+üè∞' : ''}) - $${price(idx)}
      `;
      theirProps.appendChild(label);
    }
  });
  
  if (!hasTheirProps) {
    theirProps.innerHTML = '<em style="color:#999;">No properties available</em>';
  }
  
  updateTradeSummary();
}

function updateTradeSummary() {
  const yourCash = parseInt(document.getElementById('your-cash').value) || 0;
  const theirCash = parseInt(document.getElementById('their-cash').value) || 0;
  
  const yourProps = Array.from(document.querySelectorAll('.your-prop-check:checked')).map(c => parseInt(c.value));
  const theirProps = Array.from(document.querySelectorAll('.their-prop-check:checked')).map(c => parseInt(c.value));
  
  let summary = '<div style="color:#2c3e50;"><strong>You give:</strong><br>';
  if (yourCash > 0) summary += `üí∞ $${yourCash}<br>`;
  yourProps.forEach(p => summary += `üè† Tile ${p}<br>`);
  if (yourCash === 0 && yourProps.length === 0) summary += '<em style="color:#999;">Nothing</em><br>';
  
  summary += '<br><strong>You receive:</strong><br>';
  if (theirCash > 0) summary += `üí∞ $${theirCash}<br>`;
  theirProps.forEach(p => summary += `üè† Tile ${p}<br>`);
  if (theirCash === 0 && theirProps.length === 0) summary += '<em style="color:#999;">Nothing</em>';
  summary += '</div>';
  
  document.getElementById('trade-summary').innerHTML = summary;
}

function proposeTrade() {
  const partnerId = parseInt(document.getElementById('trade-partner').value);
  const yourCash = parseInt(document.getElementById('your-cash').value) || 0;
  const theirCash = parseInt(document.getElementById('their-cash').value) || 0;
  const yourProps = Array.from(document.querySelectorAll('.your-prop-check:checked')).map(c => parseInt(c.value));
  const theirProps = Array.from(document.querySelectorAll('.their-prop-check:checked')).map(c => parseInt(c.value));
  
  // Validation
  if (yourCash === 0 && yourProps.length === 0 && theirCash === 0 && theirProps.length === 0) {
    alert('‚ùå Empty trade! Add something to the offer.');
    return;
  }
  
  if (yourCash > players[current].money) {
    alert(`‚ùå You don't have $${yourCash}!\nYou only have $${players[current].money}`);
    return;
  }
  
  if (theirCash > players[partnerId].money) {
    alert(`‚ùå ${players[partnerId].name} doesn't have $${theirCash}!\nThey only have $${players[partnerId].money}`);
    return;
  }
  
  // Create trade object
  currentTrade = {
    from: current,
    to: partnerId,
    fromCash: yourCash,
    toCash: theirCash,
    fromProps: yourProps,
    toProps: theirProps
  };
  
  document.getElementById('trade-modal').style.display = 'none';
  showTradeProposal();
}

function showTradeProposal() {
  const trade = currentTrade;
  let details = `<p style="font-size:16px; text-align:center; margin-bottom:20px;">
    <strong style="color:#2196F3;">${players[trade.from].name}</strong> wants to trade with 
    <strong style="color:#F44336;">${players[trade.to].name}</strong>
  </p>`;
  
  details += '<div style="background:#e3f2fd; padding:15px; border-radius:8px; margin:15px 0; border-left:4px solid #2196F3;">';
  details += `<strong style="color:#1976d2;">${players[trade.from].name} gives:</strong><br>`;
  if (trade.fromCash > 0) details += `üí∞ $${trade.fromCash}<br>`;
  trade.fromProps.forEach(p => details += `üè† Tile ${p}<br>`);
  if (trade.fromCash === 0 && trade.fromProps.length === 0) details += '<em>Nothing</em><br>';
  details += '</div>';
  
  details += '<div style="background:#ffebee; padding:15px; border-radius:8px; margin:15px 0; border-left:4px solid #F44336;">';
  details += `<strong style="color:#c62828;">${players[trade.to].name} gives:</strong><br>`;
  if (trade.toCash > 0) details += `üí∞ $${trade.toCash}<br>`;
  trade.toProps.forEach(p => details += `üè† Tile ${p}<br>`);
  if (trade.toCash === 0 && trade.toProps.length === 0) details += '<em>Nothing</em>';
  details += '</div>';
  
  document.getElementById('proposal-details').innerHTML = details;
  document.getElementById('trade-proposal-modal').style.display = 'block';
}

function acceptTrade() {
  const trade = currentTrade;
  
  // Execute trade
  players[trade.from].money -= trade.fromCash;
  players[trade.from].money += trade.toCash;
  players[trade.to].money -= trade.toCash;
  players[trade.to].money += trade.fromCash;
  
  // Transfer properties
  trade.fromProps.forEach(idx => {
    tiles[idx].o = trade.to;
  });
  
  trade.toProps.forEach(idx => {
    tiles[idx].o = trade.from;
  });
  
  log(`ü§ù Trade completed: ${players[trade.from].name} ‚Üî ${players[trade.to].name}!`, 'log-action');
  
  document.getElementById('trade-proposal-modal').style.display = 'none';
  currentTrade = null;
  
  draw();
  updatePanels();
}

function rejectTrade() {
  log(`‚ùå ${players[currentTrade.to].name} rejected the trade proposal`, 'log-action');
  document.getElementById('trade-proposal-modal').style.display = 'none';
  currentTrade = null;
}

function closeTradeMenu() {
  document.getElementById('trade-modal').style.display = 'none';
}

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  // Don't trigger if typing in an input field
  if (e.target.tagName === 'INPUT') return;
  
  // Don't trigger if game hasn't started
  if (!gameMode) return;
  
  // Don't trigger if not your turn in online mode
  if (gameMode === 'online' && !isMyTurn) return;
  
  let key = e.key.toLowerCase();
  
  switch(key) {
    case ' ':
      e.preventDefault();
      let rollBtn = document.getElementById('rollBtn');
      if (rollBtn && !rollBtn.disabled) {
        roll();
      }
      break;
      
    case 'enter':
      e.preventDefault();
      let endBtn = document.getElementById('endBtn');
      if (endBtn && !endBtn.disabled) {
        end();
      }
      break;
      
    case 'b':
      e.preventDefault();
      let buyBtn = document.getElementById('buyBtn');
      let bailBtn = document.getElementById('bailBtn');
      // Prioritize Buy over Bail
      if (buyBtn && !buyBtn.disabled) {
        buy();
      } else if (bailBtn && !bailBtn.disabled) {
        payBail();
      }
      break;
      
    case 's':
      e.preventDefault();
      let sellBtn = document.getElementById('sellBtn');
      if (sellBtn && !sellBtn.disabled) {
        toggleSellMode();
      }
      break;
	  case 't':
	  e.preventDefault();
	  let tradeBtn = document.getElementById('tradeBtn');
	  if (tradeBtn && !tradeBtn.disabled) {
		openTradeMenu();
	  }
	  break;
      
    case 'h':
      e.preventDefault();
      let houseBtn = document.getElementById('houseBtn');
      if (houseBtn && !houseBtn.disabled) {
        enterBuildMode('house');
      }
      break;
      
    case 'v':
      e.preventDefault();
      let villaBtn = document.getElementById('villaBtn');
      if (villaBtn && !villaBtn.disabled) {
        enterBuildMode('villa');
      }
      break;
      
    case 'escape':
      e.preventDefault();
      if (buildMode) {
        exitBuildMode();
      } else if (sellingMode) {
        toggleSellMode();
      }
      break;
  }
});

// Initialize
// Don't call resetGame on load - gameMode needs to stay null until game starts

</script>

</body>
</html>
